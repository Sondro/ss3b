#!/usr/bin/env bash

# author: Mike Gauthier <mikeg@3cx.org>
#
# ss3b - Simple S3 Backup
# A very simple script that reads from a file listing the directories
# one wishes to have backed up, tars up said directories one at a time,
# optionally compresses them, and optionally encrpyts the
# archive using a symetric cypher (gnugp - using CAST5 algorithm by
# default - default=no). Finally, it will upload to specified S3 bucket
#
# There are no configuration options in this script. All config options
# can be found in your config file (default: /etc/ss3b/ss3b.conf).

set -o nounset
set -o pipefail
IFS=$'\n\t'

#######################################################################
#######################################################################

# Setting the program name for later use.
PROGNAME=$(basename $0)

# "Declaring" some variables we'll use later.
# Why? See 'set -o nounset'. Makes find errors MUCH easier in bash.
# It's easier to check the status of a variable
# with [ "$var" = "" ] than it is with [ "${var-}" = "" ] (and a lot
# easier to read), so that's what we're "declaring" variables.
# Also setting default value where needed.
DEFCONFIG="/etc/ss3b/ss3b.conf"
config=""
clo_pathsfile=""
clo_compress=""
clo_encrypt=""
clo_bucket=""
clo_region=""
clo_inithost=""
clo_dofull=""
pathsfile=""
typeset -l compress="no" # Default is not to compress - forcing lower case
typeset -l encrypt="no"  # Default is not to encrypt - forcing lower case
bucket=""
typeset -l region="" # No default - forcing lowercase on this var
passphrase=""
aws_access_key_id=""
aws_secret_access_key=""
hostname=$(hostname -f)  # This can be overridden in the config file.
myfifo=""
fullday=7  # Default is Sunday (7). Can be set in config file.

# // FUNCTIONS //

# Output debug information to the debug log (e.g. ./ssb3-debug.out) if the
# -d option passed on the command line or debug="yes" in the config file.
# To use, simple pass a string to this function. The first time this function
# is used, an entry will be made explaining debugging has started for the
# current PID. _DEBUGLOG needs to be set before 

_DEBUG=""
function DEBUG {
	_DEBUGLOG="./debug-$(basename $0).out"
	if [ "$_DEBUG" = "yes" ]; then
		[ -n "${1-}" ] &&
			debugmsg="$1" ||
			debugmsg="Hmmm... no message sent to DEBUG function."
		echo "[$(date '+%Y-%m-%d %I:%M:%S')] $1" >> $_DEBUGLOG
	fi
}

# Produces a random alphanumeric string. Only argument is the string
# length (default to 8).
function randstr {
	thislen="${1:-8}"
	thisstr="$(cat /dev/urandom | tr -dc '[:alnum:]' | head -c $thislen)"
	echo "$thisstr"
}
# Writes to system log. One argument - the log line. PROGNAME must be set
# before this funtion. Requires logger.
function dolog {
	DEBUG "function dolog: Writing \""${1-}"\" to log."
	logline="$1"
	logger -t "$PROGNAME[$$]" "$logline" || >&2 echo "Error writing log line: $1"
}

# cleanup -- rm any temp files, start or stop things, etc
# usually called on ERR (via trap) or at the end of the script
function cleanup {
	rm -f "$cleanlist"
	rm -f "$myfifo"
}

# Simple way to exit on error - two arugment
# ARG1 = the text to output to STDERR
# ARG2 = the exit code you want to exit with (defaults to 1)
# Nice to call this with a check on $? or as the right side of an ||.
function errorexit {
	errortext="$1"
	exitcode="${2-"1"}" # if $2 is unset, value will be 1.
	DEBUG "In errorexit with errortext='$errortext' and exitcode='$exitcode'"
	>&2 echo -e "Error: $errortext" && dolog "Error: $errortext"
	exit $exitcode
}

# Simple secure way to make a temp filename.
# This exists because mktemp -u is discouaged by the author.
function mkstemp {
	echo "/tmp/$(randstr)"
}

# Usage... nuff said.

function usage {
cat <<ENDOFUSAGE

Usage: $PROGNAME [options]

All options (except debug) needed should be set from the config file. These
options are provided so overriding the config is possible (mostly for
testing). Debug output can only be enable with the -d option.

AWS id, AWS secret key, and the encryption passphrase can only be set in
the config file. This means you must ensure the config file has safe
permissions.

Options:
 -h                  Show usage.
 -c <config file>    Defaults to ${DEFCONFIG} if not provided. This
                     file must exist if config_file is not provided
                     as an argument.
 -p <path file>      File containing list of paths to back up.
                      config setting: pathsfile=<list file>
 -z                  Do compression (via gzip). Default = no
                      config setting: compress=yes
 -e                  Do encryption (via gnupg). Default = no
                      config setting: encrypt=yes
 -b <bucket name>    S3 bucket name
                      config setting: bucket=<bucket name>
 -r <region>         AWS region
                      config setting: region=<region>
 -d                  Enable debug output
                      config setting: _DEBUG=yes
 -I                  Initiate this host. Usually only run the first
                     time a host is set up.
 -F                  Force a full backup, regardless of what is set
                     in the config file. ss3b will pick up from
                     there and continue to run the full/diff cylce
                     as configured.

ENDOFUSAGE

}

# Initializes host. Creates unique host id (hostname-<random alphnumeric>),
# creates SETID file, and drops the "initialized" trigger file into the
# cachedir.
function inithost {
	echo "Initializing this host will destroy any previous hostid and setlist"
	echo "information."
	echo -n "Continue (type: yes)? "
	read contresp
	[ ! "$contresp" = "yes" ] && errorexit "Initialization aborted."
	if [ ! -d "$cachedir" ]; then
		errorexit "Cachedir ($cachedir) does not exist."
	fi
	thishostid="$hostname-$(randstr)"
	echo "$thishostid" > "$cachedir/HOSTNAME" || errorexit "Cannot create file HOSTNAME in ${cachedir}."
	touch "$cachedir/${thishostid}.SETLIST" || errorexit "Cannot create file ${thishostid}.SETLIST in ${cachedir}."
	touch "$cachedir/initialized" || erroexit "Cannot create file $cachedir/initialized in ${cachedir}."

	echo
	echo "Host successfully initialized."
	exit 0
}

# // MAIN PROGGY //

# Always trap first
trap cleanup ERR

# Deal with CLI passed options
while getopts ":h :p: :c: :z :e :b: :r: :d :I :F" opt
do
	case $opt in
		h)
			usage
			exit 0
			;;
		l)
			clo_pathsfile="$OPTARG"
			;;
		c)
			config="$OPTARG"
			;;
		z)
			clo_compress="yes"
			;;
		e)
			clo_encrypt="yes"
			;;
		b)
			clo_bucket="$OPTARG"
			;;
		r)
			clo_region="$OPTARG"
			;;
		d)
			_DEBUG="yes"
			DEBUG "Starting debug output for process id $$."
			;;
		I)
			clo_inithost="yes"
			;;
		F)
			clo_dofull="yes"
			;;
		\?)
			echo "Invalid option: -$OPTARG" >&2
			usage
			exit 1
			;;
		:)
			echo "Option -$OPTARG requires an argument." >&2
			usage
			exit 1
			;;
	esac
done


if [ "$config" = "" ]; then
	if [ ! -f "$DEFCONFIG" ]; then
		errorexit "No config file provided and default config ($DEFCONFIG) does not exist. Try $0 -h."
	else
		DEBUG "There is no config file set. Using default - '$DEFCONFIG'"
		config="$DEFCONFIG"
	fi
fi

# Source config file

DEBUG "Pulling in config from config file '$config'"
source "$config" || errorexit "Failed to source config file '$config'"


# Override config from CLI provided options
[ -n "$clo_pathsfile" ] && pathsfile=$clo_pathsfile
[ -n "$clo_compress" ] && compress=$clo_compress
[ -n "$clo_encrypt" ] && encrypt=$clo_encrypt
[ -n "$clo_bucket" ] && bucket=$clo_bucket
[ -n "$clo_region" ] && region=$clo_region

# Check that all required variables are set, otherwise error
misconf="" # "declaring"
[ -z "$cachedir" ] && misconf+=" cachedir"
[ -z "$pathsfile" ] && misconf+=" pathsfile"
[ -z "$bucket" ] && misconf+=" bucket"
[ -z "$region" ] && misconf+=" region"
[ -z "$aws_access_key_id" ] && misconf+=" aws_access_key_id"
[ -z "$aws_secret_access_key" ] && misconf+=" aws_secret_access-key"
if [ "$encrypt" = "yes" ]; then
	[ -z "$passphrase" ] && misconf+=" passphrase"
fi

if [ -n "$misconf" ]; then
	misconfmsg="The following config parameters are not set, but must be:"
	misconfmsg+="$misconf"
	errorexit "$misconfmsg"
else
	mesg="Config params set as:"
	mesg+=" cachedir='$cachedir'"
	mesg+=" pathsfile='$pathsfile'"
	mesg+=" bucket='$bucket'"
	mesg+=" region='$region'"
	mesg+=" compress='$compress'"
	mesg+=" encrypt='$encrypt'"
	DEBUG "$mesg"
fi

# If -I (initialize host) was set, run inithost
[ "$clo_inithost" = "yes" ] && inithost

# Check that this system has been initiated (at least locally).
# Error and exit if it hasn't.
if [ ! -f "$cachedir/initialized" ]; then
	errorexit "This host has not been initialized or something \"bad\" has happened in the cache dir ($cachedir). See -I option to initialize."
fi

hostid="$(head -n 1 $cachedir/HOSTNAME)"

# Read in all directories from pathsfile then clean up the list to remove
# comments and blank lines and such. Trying to do a few sane things like
# dropping lines that are commented out and blank lines. This can easily be
# broken with some thought (e.g. putting quotes around a line in pathsfile).
declare -a targets targets_raw
mapfile -t targets_raw < "$pathsfile" || errorexit "Unable to open pathsfile $pathsfile"

for (( x=0; x<${#targets_raw[@]}; x++ )); do
	thisline="${targets_raw[$x]}"
	# Note that the single quotes around the '#' in the regex are not
	# actually needed (or desired). It doesn't change the way the regex works,
	# but it does work around a nasty bug in vim that mucks up the syntax
	# highlghting. I like vim.
	[[ "$thisline" =~ ^\ *'#' ]] && continue
	[[ ! "$thisline" =~ ^.*[:alnum:].*$ ]] && continue
	targets+=("$thisline")
done

cleanlist=$(mkstemp)
DEBUG "After reading in pathsfile and cleaning up, this is the list"
for (( x=0; x<${#targets[@]}; x++ )); do
	echo "${targets[$x]}" >> $cleanlist
	DEBUG "$x: ${targets[$x]}"
done

# Removing leading slashes from the items in cleanlist
sed -i -e 's/\///' $cleanlist


budate="$(date +%Y%m%d%H%M)"

# TODO - Check if full or diff and set flag (is it full back up day?)
# TODO - Need to set config var for full back up day -- also check to
#        see if full backup was forced from CLI or it is the first
#        ever run (could use a value in "initialized" trigger file).
# TODO - Get or set (new) setid.

# Sanity check current value of $fullday. If <0 or >7, error and exit.
# $fullday can only between 0 and 7 (Monday through Sunday)
[ $fullday -le 0 -o $fullday -gt 7 ] && errorexit "fullday in config is set to an impossible value."

butype="diff"
[ $fullday -eq $(date +%u) ] && butype="full"
[ "$clo_dofull" = "yes" ] && butype="full"

echo "butype = $butype"
arcprefix="${hostid}.SETID.${butype}.${budate}"

exit


########################################################################
########################################################################
########################################################################
########################################################################

# Finally... we do the actual backup after ALL that parsing, loading,
# and logic checking.

export GZIP=-9
export AWS_ACCESS_KEY_ID=$aws_access_key_id
export AWS_SECRET_ACCESS_KEY=$aws_secret_access_key

case $compress in
	yes|ye|yes|1|true)
		compressopt="--gzip"
		compsuffix=".tgz"
		;;
	*)
		compressopt=""
		compsuffix=".tar"
esac

case $encrypt in
	yes|ye|yes|1|true)
		myfifo=$(mkstemp)
		mkfifo -m 600 $myfifo
		echo "$passphrase" > $myfifo &
		exec 3<$myfifo
		encryptcmd="openssl enc -pass fd:3 -aes-256-cbc -salt |"
		encsuffix=".enc"
		;;
	*)
		encryptcmd=""
		encsuffix=""
esac

tarcmd="tar --create --directory=/ --files-from=$cleanlist --listed-incremental=/tmp/thisincremental --level=0 $compressopt |"
awscmd="aws --region $region s3 cp - s3://$bucket/${arcprefix}${compsuffix}${encsuffix} --quiet"

eval "$tarcmd $encryptcmd $awscmd"

cleanup

#!/usr/bin/env bash

# author: Mike Gauthier <mikeg@3cx.org>
#
# ss3b - Simple S3 Backup
# A very simple script that reads from a file listing the directories
# one wishes to have backed up, tars up said directories one at a time,
# optionally compresses them, and optionally encrpyts the
# archive using a symetric cypher (gnugp - using CAST5 algorithm by
# default - default=no). Finally, it will upload to specified S3 bucket
#
# There are no configuration options in this script. All config options
# can be found in your config file (default: /etc/ss3b/ss3b.conf).

set -o nounset
set -o pipefail
IFS=$'\n\t'

#######################################################################
#######################################################################

# Setting the program name for later use.
PROGNAME=$(basename $0)

# "Declaring" some variables we'll use later.
# Why? See 'set -o unset'. It's easier to check the status of a variable
# with [ "$var" = "" ] than it is with [ "${var-}" = "" ].
# Also setting default value where needed.
DEFCONFIG="/etc/ss3b/ss3b.conf"
config=""
clo_pathsfile=""
clo_compress=""
clo_encrypt=""
clo_bucket=""
clo_region=""
pathsfile=""
compress="no" # Default is not to compress
encrypt="no"  # Default is not to encrypt
bucket=""
region=""
passphrase=""
aws_access_key_id=""
aws_secret_access_key=""
hostname=$(hostname -f)  # This can be overridden in the config file.

# // FUNCTIONS //

# Output debug information to the debug log (e.g. ./ssb3-debug.out) if the
# -d option passed on the command line or debug="yes" in the config file.
# To use, simple pass a string to this function. The first time this function
# is used, an entry will be made explaining debugging has started for the
# current PID. _DEBUGLOG needs to be set before 

_DEBUG=""
function DEBUG {
	_DEBUGLOG="./debug-$(basename $0).out"
	if [ "$_DEBUG" = "yes" ]; then
		[ -n "${1-}" ] &&
			debugmsg="$1" ||
			debugmsg="Hmmm... no message sent to DEBUG function."
		echo "[$(date '+%Y-%m-%d %I:%M:%S')] $1" >> $_DEBUGLOG
	fi
}

# Writes to system log. One argument - the log line. PROGNAME must be set
# before this funtion. Requires logger.
function dolog {
	DEBUG "function dolog: Writing \""${1-}"\" to log."
	logline="$1"
	logger -t "$PROGNAME[$$]" "$logline" || >&2 echo "Error writing log line: $1"
}

# cleanup -- rm any temp files, start or stop things, etc
# usually called on ERR (via trap) or at the end of the script
function cleanup {
	rm -f "$cleanlist"
	rm -f "$myfifo"
}

# Simple way to exit on error - two arugment
# ARG1 = the text to output to STDERR
# ARG2 = the exit code you want to exit with (defaults to 1)
# Nice to call this with a check on $? or as the right side of an ||.
function errorexit {
	errortext="$1"
	exitcode="${2-"1"}" # if $2 is unset, value will be 1.
	DEBUG "In errorexit with errortext='$errortext' and exitcode='$exitcode'"
	>&2 echo -e "Error: $errortext" && dolog "Error: $errortext"
	exit $exitcode
}

# Simple secure way to make a temp filename.
# This exists because mktemp -u is discouaged by the author.
function mkstemp {
	echo "/tmp/$(cat /dev/urandom | tr -dc '[:alnum:]' | head -c 8)"
}

# Usage... nuff said.

function usage {
cat <<ENDOFUSAGE

Usage: $PROGNAME [options]

All options (except debug) needed should be set from the config file. These
options are provided so overriding the config is possible (mostly for
testing). Debug output can only be enable with the -d option.

AWS id, AWS secret key, and the encryption passphrase can only be set in
the config file. This means you must ensure the config file has safe
permissions.

Options:
 -h                  Show usage.
 -c <config file>    Defaults to ${DEFCONFIG} if not provided. This
                     file must exist if config_file is not provided
                     as an argument.
 -p <path file>      File containing list of paths to back up.
                      config setting: pathsfile=<list file>
 -z                  Do compression (via gzip). Default = no
                      config setting: compress=yes
 -e                  Do encryption (via gnupg). Default = no
                      config setting: encrypt=yes
 -b <bucket name>    S3 bucket name
                      config setting: bucket=<bucket name>
 -r <region>         AWS region
                      config setting: region=<region>
 -d                  Enable debug output
                      config setting: _DEBUG=yes

ENDOFUSAGE

}


# // MAIN PROGGY //

# Always trap first
trap cleanup ERR

# Deal with CLI passed options
while getopts ":h :p: :c: :z :e :b: :r: :d" opt
do
	case $opt in
		h)
			usage
			exit 0
			;;
		l)
			clo_pathsfile="$OPTARG"
			;;
		c)
			config="$OPTARG"
			;;
		z)
			clo_compress="yes"
			;;
		e)
			clo_encrypt="yes"
			;;
		b)
			clo_bucket="$OPTARG"
			;;
		r)
			clo_region="$OPTARG"
			;;
		d)
			_DEBUG="yes"
			DEBUG "Starting debug output for process id $$."
			;;
		\?)
			echo "Invalid option: -$OPTARG" >&2
			usage
			exit 1
			;;
		:)
			echo "Option -$OPTARG requires an argument." >&2
			usage
			exit 1
			;;
	esac
done


if [ "$config" = "" ]; then
	if [ ! -f "$DEFCONFIG" ]; then
		errorexit "No config file provided and default config ($DEFCONFIG) does not exist. Try $0 -h."
	else
		DEBUG "There is no config file set. Using default - '$DEFCONFIG'"
		config="$DEFCONFIG"
	fi
fi

# Source config file

DEBUG "Pulling in config from config file '$config'"
source "$config" || errorexit "Failed to source config file '$config'"


# Override config from CLI provided options
[ -n "$clo_pathsfile" ] && pathsfile=$clo_pathsfile
[ -n "$clo_compress" ] && compress=$clo_compress
[ -n "$clo_encrypt" ] && encrypt=$clo_encrypt
[ -n "$clo_bucket" ] && bucket=$clo_bucket
[ -n "$clo_region" ] && region=$clo_region

# Check that all required variables are set, otherwise error
misconf="" # "declaring"
[ -z "$cachedir" ] && misconf+=" cachedir"
[ -z "$pathsfile" ] && misconf+=" pathsfile"
[ -z "$bucket" ] && misconf+=" bucket"
[ -z "$region" ] && misconf+=" region"
[ -z "$aws_access_key_id" ] && misconf+=" aws_access_key_id"
[ -z "$aws_secret_access_key" ] && misconf+=" aws_secret_access-key"
if [ "$encrypt" = "yes" ]; then
	[ -z "$passphrase" ] && misconf+=" passphrase"
fi

if [ -n "$misconf" ]; then
	misconfmsg="The following config parameters are not set, but must be:"
	misconfmsg+="$misconf"
	errorexit "$misconfmsg"
else
	mesg="Config params set as:"
	mesg+=" cachedir='$cachedir'"
	mesg+=" pathsfile='$pathsfile'"
	mesg+=" bucket='$bucket'"
	mesg+=" region='$region'"
	mesg+=" compress='$compress'"
	mesg+=" encrypt='$encrypt'"
	DEBUG "$mesg"
fi

# Read in all directories from pathsfile then clean up the list to remove
# comments and blank lines and such. Trying to do a few sane things like
# dropping lines that are commented out and blank lines. This can easily be
# broken with some thought (e.g. putting quotes around a line in pathsfile).
declare -a targets targets_raw
mapfile -t targets_raw < "$pathsfile" || errorexit "Unable to open pathsfile $pathsfile"

for (( x=0; x<${#targets_raw[@]}; x++ )); do
	thisline="${targets_raw[$x]}"
	# Note that the single quotes around the '#' in the regex are not
	# actually needed (or desired). It doesn't change the way the regex works,
	# but it does work around a nasty bug in vim that mucks up the syntax
	# highlghting.
	[[ "$thisline" =~ ^\ *'#' ]] && continue
	[[ ! "$thisline" =~ ^.*[:alnum:].*$ ]] && continue
	targets+=("$thisline")
done

cleanlist=$(mkstemp)
DEBUG "After reading in pathsfile and cleaning up, this is the list"
for (( x=0; x<${#targets[@]}; x++ )); do
	echo "${targets[$x]}" >> $cleanlist
	DEBUG "$x: ${targets[$x]}"
done

# Removing leading slashes from the items in cleanlist
sed -i -e 's/\///' $cleanlist

# Finally... we do the actual backup after ALL that parsing, loading,
# and logic checking.

export GZIP=-9
export AWS_ACCESS_KEY_ID=$aws_access_key_id
export AWS_SECRET_ACCESS_KEY=$aws_secret_access_key

myfifo=$(mkstemp)

mkfifo -m 600 $myfifo
echo "$passphrase" > $myfifo &
exec 3<$myfifo

tar	--create \
	--directory=/ \
	--files-from=$cleanlist \
	--listed-incremental=/tmp/thisincremental \
	--level=0 \
	--gzip |
openssl enc -pass fd:3 \
	-aes-256-cbc -salt |
aws	--region $region \
	s3 cp - s3://$bucket/thisarchive3.tgz.gpg --quiet

cleanup
